using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;
using System.Linq;
using MetaTypes.Generator.Common;
using MetaTypes.Generator.EfCore.Common;

namespace MetaTypes.Generator;

[Generator]
public class MetaTypeSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get configuration from AdditionalFiles (JSON configuration)
        var configuration = context.AdditionalTextsProvider
            .Collect()
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((combined, _) => 
            {
                var (additionalFiles, configProvider) = combined;
                var fullConfig = ConfigurationLoader.LoadFromAdditionalFiles(additionalFiles, configProvider);
                return fullConfig.BaseGenerator!;
            });

        // Combine compilation with configuration
        var compilationAndConfig = context.CompilationProvider.Combine(configuration);

        context.RegisterSourceOutput(compilationAndConfig,
            (spc, source) => 
            {
                var compilation = source.Left;
                var config = source.Right;
                
                Execute(compilation, config, spc);
            });
    }

    private static void Execute(Compilation compilation, BaseGeneratorOptions config, SourceProductionContext context)
    {
        // Build discovery methods based on configuration
        var discoveryMethods = new List<TypeDiscoverMethod>();
        discoveryMethods.AddRange(UnifiedTypeDiscovery.GetCommonDiscoveryMethods());
        
        if (config.EnableEfCoreDetection)
        {
            discoveryMethods.AddRange(EfCoreDiscoveryMethods.GetEfCoreDiscoveryMethods());
        }
        
        // Use the unified discovery system with configured methods
        var discoveredTypes = UnifiedTypeDiscovery.DiscoverTypes(compilation, discoveryMethods.ToArray());
        
        // Always add diagnostic file for debugging configuration
        var discoveryStats = discoveredTypes
            .GroupBy(dt => $"{dt.Source}-{dt.DiscoveredBy}")
            .Select(g => $"{g.Key}: {g.Count()}")
            .ToList();
            
        context.AddSource("_MetaTypesGeneratorDiagnostic.g.cs", $@"
// Generated by MetaTypes base generator at {System.DateTime.Now}
// Assembly: {compilation.Assembly.Name}
// ConfiguredAssemblyName: {config.AssemblyName}
// EfCore Detection Enabled: {config.EnableEfCoreDetection}
// Diagnostic Files Enabled: {config.EnableDiagnosticFiles}
// Config Keys Found: {config.DebugInfo}
// Discovery Methods: {discoveryMethods.Count} (Common: {UnifiedTypeDiscovery.GetCommonDiscoveryMethods().Length}, EfCore: {(config.EnableEfCoreDetection ? EfCoreDiscoveryMethods.GetEfCoreDiscoveryMethods().Length : 0)})
// Discovered types: {discoveredTypes.Count}
// Discovery breakdown: {string.Join(", ", discoveryStats)}
// Types: {string.Join(", ", discoveredTypes.Select(dt => $"{dt.TypeSymbol.Name} ({dt.Source} by {dt.DiscoveredBy})"))}
");

        if (discoveredTypes.Count == 0)
        {
            return;
        }

        // Group discovered types by their source assembly for proper namespace generation
        var typesByAssembly = discoveredTypes.GroupBy(dt => dt.TypeSymbol.ContainingAssembly.Name).ToList();

        foreach (var assemblyGroup in typesByAssembly)
        {
            var assemblyName = assemblyGroup.Key;
            var typesInAssembly = assemblyGroup.Select(dt => dt.TypeSymbol).ToList();

            // Use assembly name as namespace, or configured override if provided
            var targetNamespace = !string.IsNullOrEmpty(config.AssemblyName) ? config.AssemblyName! : assemblyName;
            
            // Generate MetaTypes provider class for this assembly
            var providerSource = CoreMetaTypeGenerator.GenerateMetaTypesProvider(targetNamespace, typesInAssembly);
            context.AddSource($"{assemblyName}MetaTypes.g.cs", providerSource);

            // Generate individual MetaType classes for this assembly
            // Pass all discovered types for cross-reference detection
            var allDiscoveredTypeSymbols = discoveredTypes.Select(dt => dt.TypeSymbol).ToList();
            foreach (var typeSymbol in typesInAssembly)
            {
                var metaTypeSource = CoreMetaTypeGenerator.GenerateMetaTypeClass(typeSymbol, targetNamespace, allDiscoveredTypeSymbols);
                context.AddSource($"{assemblyName}_{typeSymbol.Name}MetaType.g.cs", metaTypeSource);
            }
        }
    }
}