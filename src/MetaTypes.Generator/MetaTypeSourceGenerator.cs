using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Text.Json;
using System.Linq;
using MetaTypes.Generator.Common;
using MetaTypes.Generator.Common.Generator;

namespace MetaTypes.Generator;

[Generator]
public class MetaTypeSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get configuration from AdditionalFiles (JSON configuration)
        var configuration = context.AdditionalTextsProvider
            .Collect()
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((combined, _) => 
            {
                var (additionalFiles, configProvider) = combined;
                var fullConfig = ConfigurationLoader.LoadFromAdditionalFiles(additionalFiles, configProvider);
                return fullConfig.BaseGenerator!;
            });

        // Combine compilation with configuration
        var compilationAndConfig = context.CompilationProvider.Combine(configuration);

        context.RegisterSourceOutput(compilationAndConfig,
            (spc, source) => 
            {
                var compilation = source.Left;
                var config = source.Right;
                
                Execute(compilation, config, spc);
            });
    }

    private static void Execute(Compilation compilation, BaseGeneratorOptions config, SourceProductionContext context)
    {
        // Use the new plugin-based discovery system - all IDiscoveryMethod implementations are auto-discovered via reflection
        var discoveryResult = UnifiedTypeDiscovery.GetDiscoveryResult(compilation, config.Discovery);
        var discoveredTypes = discoveryResult.DiscoveredTypes;
        
        // Always add diagnostic file for debugging configuration
        var discoveryStats = discoveredTypes
            .GroupBy(dt => $"{dt.Source}-{dt.PrimaryDiscoveredBy}")
            .Select(g => $"{g.Key}: {g.Count()}")
            .ToList();
            
        context.AddSource("_MetaTypesGeneratorDiagnostic.g.cs", $@"
// Generated by MetaTypes base generator at {System.DateTime.Now}
// Assembly: {compilation.Assembly.Name}
// ConfiguredNamespace: {config.GeneratedNamespace}
// Config Keys Found: {config.DebugInfo}
//
// ORCHESTRATED CONFIGURATION:
// - BaseMetaTypes: {config.Generation.BaseMetaTypes}
// - Discovery.Syntax: {config.Discovery.Syntax}
// - Discovery.CrossAssembly: {config.Discovery.CrossAssembly}
// - Discovery.Methods: [{string.Join(", ", config.Discovery.Methods.Methods)}]
//
// DISCOVERY EXECUTION:
// - Success: {discoveryResult.Success}
// - Methods Used: {string.Join(", ", discoveryResult.MethodsUsed)}
// - Warnings: {string.Join("; ", discoveryResult.Warnings)}
// - Errors: {string.Join("; ", discoveryResult.Errors)}
//
// CONFIGURATION:
// - EnableDiagnosticFiles: {config.EnableDiagnosticFiles}
//
// DISCOVERY RESULTS:
// - Discovered types: {discoveredTypes.Count}
// - Discovery breakdown: {string.Join(", ", discoveryStats)}
// - Types: {string.Join(", ", discoveredTypes.Select(dt => $"{dt.TypeSymbol.Name} ({dt.Source} by [{string.Join(", ", dt.DiscoveredBy)}])"))}
");

        if (discoveredTypes.Count == 0)
        {
            return;
        }

        // Generate base MetaTypes if configured
        if (config.Generation.BaseMetaTypes)
        {
            GenerateBaseMetaTypes(discoveredTypes, config, context);
        }
        else
        {
            // Add a diagnostic to show that types were discovered but base generation was skipped
            context.AddSource("_BaseGenerationSkipped.g.cs", $@"
// Base MetaType generation skipped by configuration
// BaseMetaTypes = {config.Generation.BaseMetaTypes}
// Discovered types that were NOT generated: {discoveredTypes.Count}
// Types: {string.Join(", ", discoveredTypes.Select(dt => dt.TypeSymbol.Name))}
// Configure BaseMetaTypes = true to generate base classes with this generator
");
        }

        // Always execute vendor generators regardless of base generation
        ExecuteVendorGenerators(compilation, config, discoveredTypes, context);
    }

    private static void GenerateBaseMetaTypes(
        IList<DiscoveredType> discoveredTypes,
        BaseGeneratorOptions config,
        SourceProductionContext context)
    {
        // Group discovered types by their source assembly for proper namespace generation
        var typesByAssembly = discoveredTypes.GroupBy(dt => dt.TypeSymbol.ContainingAssembly.Name).ToList();

        foreach (var assemblyGroup in typesByAssembly)
        {
            var assemblyName = assemblyGroup.Key;
            var typesInAssembly = assemblyGroup.Select(dt => dt.TypeSymbol).ToList();

            // Use MetaTypes' shared assembly name logic via AssemblyNameProvider
            var targetNamespace = AssemblyNameProvider.Instance.GetTargetNamespace(assemblyName, config);
            
            // Generate MetaTypes provider class for this assembly
            var providerSource = CoreMetaTypeGenerator.GenerateMetaTypesProvider(targetNamespace, typesInAssembly);
            context.AddSource($"{assemblyName}MetaTypes.g.cs", providerSource);

            // Generate individual MetaType classes for this assembly
            // Pass all discovered types for cross-reference detection
            var allDiscoveredTypeSymbols = discoveredTypes.Select(dt => dt.TypeSymbol).ToList();
            foreach (var typeSymbol in typesInAssembly)
            {
                var metaTypeSource = CoreMetaTypeGenerator.GenerateMetaTypeClass(typeSymbol, targetNamespace, allDiscoveredTypeSymbols);
                context.AddSource($"{assemblyName}_{typeSymbol.Name}MetaType.g.cs", metaTypeSource);
            }
        }
    }

    private static void ExecuteVendorGenerators(
        Compilation compilation,
        BaseGeneratorOptions config,
        IList<DiscoveredType> discoveredTypes,
        SourceProductionContext context)
    {
        // Get available vendors for diagnostics
        var availableVendors = VendorGeneratorRegistry.GetAvailableVendorNames().ToList();
        
        // Get enabled vendor generators based on configuration
        var vendorGenerators = VendorGeneratorRegistry.GetEnabledVendorGenerators(config.EnabledVendors);
        var enabledVendorNames = vendorGenerators.Select(v => v.VendorName).ToList();

        // Add vendor diagnostics
        if (config.EnableDiagnosticFiles)
        {
            context.AddSource("_VendorDiagnostic.g.cs", $@"
// Vendor Generator Diagnostic
// Generated at: {System.DateTime.Now}
// 
// Available Vendors: [{string.Join(", ", availableVendors)}]
// Enabled Vendors: [{string.Join(", ", enabledVendorNames)}]
// Vendor Configs: [{string.Join(", ", config.VendorConfigs?.Keys.ToArray() ?? Array.Empty<string>())}]
");
        }

        foreach (var vendorGenerator in vendorGenerators)
        {
            try
            {
                // Configure the vendor generator with its specific config
                System.Text.Json.JsonElement? vendorConfig = null;
                if (config.VendorConfigs?.TryGetValue(vendorGenerator.VendorName, out var configValue) == true)
                {
                    vendorConfig = configValue;
                }
                vendorGenerator.Configure(vendorConfig);
                
                // Create context for vendor generator
                var vendorContext = new GeneratorContext
                {
                    EnableDiagnostics = config.EnableDiagnosticFiles,
                    Properties = new Dictionary<string, string>
                    {
                        ["BaseMetaTypesGenerated"] = config.Generation.BaseMetaTypes.ToString()
                    }
                };

                // Generate vendor-specific files
                var generatedFiles = vendorGenerator.Generate(discoveredTypes, compilation, vendorContext);
                
                foreach (var file in generatedFiles)
                {
                    context.AddSource(file.FileName, file.Content);
                }

                // Add diagnostic if enabled
                if (config.EnableDiagnosticFiles)
                {
                    var vendorTypes = discoveredTypes
                        .Where(dt => dt.PrimaryDiscoveredBy.StartsWith($"{vendorGenerator.VendorName}."))
                        .Select(dt => dt.TypeSymbol.Name)
                        .ToList();

                    if (vendorTypes.Any())
                    {
                        context.AddSource($"_{vendorGenerator.VendorName}VendorDiagnostic.g.cs", $@"
// {vendorGenerator.VendorName} Vendor Generator Diagnostic
// Generated at: {System.DateTime.Now}
// Description: {vendorGenerator.Description}
// Types processed: {vendorTypes.Count}
// Types: {string.Join(", ", vendorTypes)}
");
                    }
                }
            }
            catch (Exception ex)
            {
                // Add error diagnostic
                context.AddSource($"_{vendorGenerator.VendorName}VendorError.g.cs", $@"
// ERROR in {vendorGenerator.VendorName} vendor generator
// Exception: {ex.Message}
// StackTrace: {ex.StackTrace}
");
            }
        }
    }
}