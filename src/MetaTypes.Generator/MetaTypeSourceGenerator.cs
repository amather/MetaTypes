using MetaTypes.Generator.Common.Generator;
using MetaTypes.Generator.Configuration;
using MetaTypes.Generator.Discovery;
using MetaTypes.Generator.Generator;
using MetaTypes.Generator.Vendor.MetaTypes.Generation;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace MetaTypes.Generator;

[Generator]
public class MetaTypeSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            //Debugger.Launch();
        }
#endif 
        // Get configuration from AdditionalFiles (JSON configuration)
        var configuration = context.AdditionalTextsProvider
            .Collect()
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((combined, _) => 
            {
                var (additionalFiles, configProvider) = combined;
                var fullConfig = ConfigurationLoader.LoadFromAdditionalFiles(additionalFiles, configProvider);
                return fullConfig;
            });

        // Combine compilation with configuration
        var compilationAndConfig = context.CompilationProvider.Combine(configuration);

        context.RegisterSourceOutput(compilationAndConfig,
            (spc, source) => 
            {
                var compilation = source.Left;
                var config = source.Right;
                
                Execute(compilation, config, spc);
            });
    }

    private static void Execute(Compilation compilation, MetaTypesOptions config, SourceProductionContext context)
    {
        // discover types based on configuration
        var discoveryResult = TypeDiscovery.RunTypeDiscovery(compilation, config);
        var discoveredTypes = discoveryResult.DiscoveredTypes;
        
        // Always add diagnostic file for debugging configuration
        var discoveryStats = discoveredTypes
            .GroupBy(dt => $"{dt.Source}-{dt.PrimaryDiscoveredBy}")
            .Select(g => $"{g.Key}: {g.Count()}")
            .ToList();
            
        context.AddSource("_MetaTypesGeneratorDiagnostic.g.cs", $@"
// Generated by MetaTypes base generator at {System.DateTime.Now}
// EnableDiagnosticFiles: {config.EnableDiagnosticFiles}
// Assembly: {compilation.Assembly.Name}
// ConfiguredNamespace: {config.GeneratedNamespace}
// Config Keys Found: {config.DebugInfo}
//
// CONFIGURATION:
// - GenerateBaseMetaTypes: {config.GenerateBaseMetaTypes}
// - DiscoverCrossAssembly: {config.DiscoverCrossAssembly}
// - DiscoverMethods: [{string.Join(", ", config.DiscoverMethods)}]
//
// TYPE DISCOVERY:
// - Success: {discoveryResult.Success}
// - Methods Used: {string.Join(", ", discoveryResult.MethodsUsed)}
// - Warnings: {string.Join("; ", discoveryResult.Warnings)}
// - Errors: {string.Join("; ", discoveryResult.Errors)}
//
// DISCOVERY RESULTS:
// - Discovered types: {discoveredTypes.Count}
// - Discovery breakdown: {string.Join(", ", discoveryStats)}
// - Types: {string.Join("\n//    ", discoveredTypes.Select(dt => $"{dt.TypeSymbol.Name} ({dt.Source} by [{string.Join(", ", dt.DiscoveredBy)}])"))}
");

        if (discoveredTypes.Count == 0)
        {
            return;
        }

        // generate base MetaTypes if configured
        if (config.GenerateBaseMetaTypes)
        {
            GenerateBaseMetaTypes(discoveredTypes, config, context, compilation);
        }
        else
        {
            // add a diagnostic to show that types were discovered but base generation was skipped
            context.AddSource("_BaseGenerationSkipped.g.cs", $@"
// Base MetaType generation skipped by configuration
// GenerateBaseMetaTypes = {config.GenerateBaseMetaTypes}
// Discovered types that were NOT generated: {discoveredTypes.Count}
// Types: {string.Join(", ", discoveredTypes.Select(dt => dt.TypeSymbol.Name))}
// Configure BaseMetaTypes = true to generate base classes with this generator
");
        }

        // always execute vendor generators regardless of base generation
        ExecuteVendorGenerators(compilation, config, discoveredTypes, context);
    }

    private static void GenerateBaseMetaTypes(
        IList<DiscoveredType> discoveredTypes,
        MetaTypesOptions config,
        SourceProductionContext context,
        Compilation compilation)
    {

        var targetNamespace = NamespaceNameProvider.GetTargetNamespace(compilation, config);
        var fileNamespace = targetNamespace; // targetNamespace.Replace(".", "");

        var allTypeSymbols = discoveredTypes.Select(dt => dt.TypeSymbol).ToList();

        // generate single unified MetaTypes provider with all discovered types
        var providerSource = BaseMetaTypeGenerator.GenerateMetaTypesProvider(targetNamespace, allTypeSymbols);
        context.AddSource($"{fileNamespace}.MetaTypes.g.cs", providerSource);

        // generate DI extension method
        var diExtensionsSource = BaseMetaTypeGenerator.GenerateServiceCollectionExtensions(targetNamespace);
        context.AddSource($"{fileNamespace}.MetaTypesServiceCollectionExtensions.g.cs", diExtensionsSource);

        // generate individual MetaType classes in the target namespace
        foreach (var typeSymbol in allTypeSymbols)
        {
            var metaTypeSource = BaseMetaTypeGenerator.GenerateMetaTypeClass(typeSymbol, targetNamespace, allTypeSymbols, useCrossAssemblyReferences: true);
            context.AddSource($"{fileNamespace}_{typeSymbol.Name}MetaType.g.cs", metaTypeSource);
        }

    }

    private static void ExecuteVendorGenerators(
        Compilation compilation,
        MetaTypesOptions config,
        IList<DiscoveredType> discoveredTypes,
        SourceProductionContext context)
    {
        // Get available vendors for diagnostics
        var availableVendors = VendorGeneratorRegistry.GetAvailableVendorNames().ToList();
        
        // Get enabled vendor generators based on configuration
        var vendorGenerators = VendorGeneratorRegistry.GetEnabledVendorGenerators(config.EnabledVendors);
        var enabledVendorNames = vendorGenerators.Select(v => v.VendorName).ToList();

        // Add vendor diagnostics
        if (config.EnableDiagnosticFiles)
        {
            context.AddSource("_VendorDiagnostic.g.cs", $@"
// Vendor Generator Diagnostic
// Generated at: {System.DateTime.Now}
// 
// Available Vendors: [{string.Join(", ", availableVendors)}]
// Enabled Vendors: [{string.Join(", ", enabledVendorNames)}]
// Vendor Configs: [{string.Join(", ", config.VendorConfigs?.Keys.ToArray() ?? Array.Empty<string>())}]
");
        }

        foreach (var vendorGenerator in vendorGenerators)
        {
            try
            {
                // Configure the vendor generator with its specific config
                System.Text.Json.JsonElement? vendorConfig = null;
                if (config.VendorConfigs?.TryGetValue(vendorGenerator.VendorName, out var configValue) == true)
                {
                    vendorConfig = configValue;
                }
                vendorGenerator.Configure(vendorConfig);
                
                // Create context for vendor generator
                // Use the compilation assembly name as the target namespace (where the generator runs)
                var targetNamespace = NamespaceNameProvider.GetTargetNamespace(compilation, config);
                var vendorContext = new GeneratorContext
                {
                    EnableDiagnostics = config.EnableDiagnosticFiles,
                    TargetNamespace = targetNamespace,
                    Properties = new Dictionary<string, string>
                    {
                        ["BaseMetaTypesGenerated"] = config.GenerateBaseMetaTypes.ToString()
                    }
                };

                // Generate vendor-specific files
                var generatedFiles = vendorGenerator.Generate(discoveredTypes, compilation, vendorContext);
                
                foreach (var file in generatedFiles)
                {
                    context.AddSource(file.FileName, file.Content);
                }

                // Add diagnostic if enabled
                if (config.EnableDiagnosticFiles)
                {
                    var vendorTypes = discoveredTypes
                        .Where(dt => dt.PrimaryDiscoveredBy.StartsWith($"{vendorGenerator.VendorName}."))
                        .Select(dt => dt.TypeSymbol.Name)
                        .ToList();

                    if (vendorTypes.Any())
                    {
                        context.AddSource($"_{vendorGenerator.VendorName}VendorDiagnostic.g.cs", $@"
// {vendorGenerator.VendorName} Vendor Generator Diagnostic
// Generated at: {System.DateTime.Now}
// Description: {vendorGenerator.Description}
// Types processed: {vendorTypes.Count}
// Types: {string.Join(", ", vendorTypes)}
");
                    }
                }
            }
            catch (Exception ex)
            {
                // Add error diagnostic
                context.AddSource($"_{vendorGenerator.VendorName}VendorError.g.cs", $@"
// ERROR in {vendorGenerator.VendorName} vendor generator
// Exception: {ex.Message}
// StackTrace: {ex.StackTrace}
");
            }
        }
    }
}