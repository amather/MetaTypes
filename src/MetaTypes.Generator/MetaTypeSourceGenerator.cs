using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;
using System.Linq;
using MetaTypes.Generator.Common;
using MetaTypes.Generator.EfCore.Common;

namespace MetaTypes.Generator;

[Generator]
public class MetaTypeSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get configuration from AdditionalFiles (JSON configuration)
        var configuration = context.AdditionalTextsProvider
            .Collect()
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((combined, _) => 
            {
                var (additionalFiles, configProvider) = combined;
                var fullConfig = ConfigurationLoader.LoadFromAdditionalFiles(additionalFiles, configProvider);
                return fullConfig.BaseGenerator!;
            });

        // Combine compilation with configuration
        var compilationAndConfig = context.CompilationProvider.Combine(configuration);

        context.RegisterSourceOutput(compilationAndConfig,
            (spc, source) => 
            {
                var compilation = source.Left;
                var config = source.Right;
                
                Execute(compilation, config, spc);
            });
    }

    private static void Execute(Compilation compilation, BaseGeneratorOptions config, SourceProductionContext context)
    {
        // Register EfCore discovery methods if EfCore detection is enabled
        if (config.EnableEfCoreDetection)
        {
            EfCoreDiscoveryMethods.RegisterWithUnifiedDiscovery();
        }
        
        // Use the new configuration-driven discovery system
        var discoveredTypes = UnifiedTypeDiscovery.DiscoverTypes(compilation, config.Discovery);
        
        // Legacy fallback: if new discovery didn't find anything, try legacy methods
        if (discoveredTypes.Count == 0 && config.EnableEfCoreDetection)
        {
            var legacyMethods = new List<TypeDiscoverMethod>();
            legacyMethods.AddRange(UnifiedTypeDiscovery.GetCommonDiscoveryMethods());
            legacyMethods.AddRange(EfCoreDiscoveryMethods.GetEfCoreDiscoveryMethods());
            discoveredTypes = UnifiedTypeDiscovery.DiscoverTypes(compilation, legacyMethods.ToArray());
        }
        
        // Always add diagnostic file for debugging configuration
        var discoveryStats = discoveredTypes
            .GroupBy(dt => $"{dt.Source}-{dt.DiscoveredBy}")
            .Select(g => $"{g.Key}: {g.Count()}")
            .ToList();
            
        context.AddSource("_MetaTypesGeneratorDiagnostic.g.cs", $@"
// Generated by MetaTypes base generator at {System.DateTime.Now}
// Assembly: {compilation.Assembly.Name}
// ConfiguredAssemblyName: {config.AssemblyName}
// Config Keys Found: {config.DebugInfo}
//
// ORCHESTRATED CONFIGURATION:
// - BaseMetaTypes: {config.Generation.BaseMetaTypes}
// - Discovery.Syntax: {config.Discovery.Syntax}
// - Discovery.CrossAssembly: {config.Discovery.CrossAssembly}
// - Discovery.Methods.MetaTypesAttributes: {config.Discovery.Methods.MetaTypesAttributes}
// - Discovery.Methods.MetaTypesReferences: {config.Discovery.Methods.MetaTypesReferences}
//
// LEGACY COMPATIBILITY:
// - EnableEfCoreDetection: {config.EnableEfCoreDetection}
// - EnableDiagnosticFiles: {config.EnableDiagnosticFiles}
//
// DISCOVERY RESULTS:
// - Discovered types: {discoveredTypes.Count}
// - Discovery breakdown: {string.Join(", ", discoveryStats)}
// - Types: {string.Join(", ", discoveredTypes.Select(dt => $"{dt.TypeSymbol.Name} ({dt.Source} by {dt.DiscoveredBy})"))}
");

        if (discoveredTypes.Count == 0)
        {
            return;
        }

        // Check if this generator should generate base MetaTypes
        if (!config.Generation.BaseMetaTypes)
        {
            // This generator is configured to NOT generate base MetaTypes
            // Add a diagnostic to show that types were discovered but generation was skipped
            context.AddSource("_BaseGenerationSkipped.g.cs", $@"
// Base MetaType generation skipped by configuration
// BaseMetaTypes = {config.Generation.BaseMetaTypes}
// Discovered types that were NOT generated: {discoveredTypes.Count}
// Types: {string.Join(", ", discoveredTypes.Select(dt => dt.TypeSymbol.Name))}
// Configure BaseMetaTypes = true to generate base classes with this generator
");
            return;
        }

        // Group discovered types by their source assembly for proper namespace generation
        var typesByAssembly = discoveredTypes.GroupBy(dt => dt.TypeSymbol.ContainingAssembly.Name).ToList();

        foreach (var assemblyGroup in typesByAssembly)
        {
            var assemblyName = assemblyGroup.Key;
            var typesInAssembly = assemblyGroup.Select(dt => dt.TypeSymbol).ToList();

            // Use MetaTypes' shared assembly name logic via AssemblyNameProvider
            var targetNamespace = AssemblyNameProvider.Instance.GetTargetNamespace(assemblyName, config);
            
            // Generate MetaTypes provider class for this assembly
            var providerSource = CoreMetaTypeGenerator.GenerateMetaTypesProvider(targetNamespace, typesInAssembly);
            context.AddSource($"{assemblyName}MetaTypes.g.cs", providerSource);

            // Generate individual MetaType classes for this assembly
            // Pass all discovered types for cross-reference detection
            var allDiscoveredTypeSymbols = discoveredTypes.Select(dt => dt.TypeSymbol).ToList();
            foreach (var typeSymbol in typesInAssembly)
            {
                var metaTypeSource = CoreMetaTypeGenerator.GenerateMetaTypeClass(typeSymbol, targetNamespace, allDiscoveredTypeSymbols);
                context.AddSource($"{assemblyName}_{typeSymbol.Name}MetaType.g.cs", metaTypeSource);
            }
        }
    }
}