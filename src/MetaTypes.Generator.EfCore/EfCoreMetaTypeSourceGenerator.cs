using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;
using System.Linq;
using MetaTypes.Generator.Common;
using MetaTypes.Generator.EfCore.Common;

namespace MetaTypes.Generator.EfCore;

[Generator]
public class EfCoreMetaTypeSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get configuration from AdditionalFiles (JSON configuration)
        var configuration = context.AdditionalTextsProvider
            .Collect()
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((combined, _) => 
            {
                var (additionalFiles, configProvider) = combined;
                var fullConfig = ConfigurationLoader.LoadFromAdditionalFiles(additionalFiles, configProvider);
                return fullConfig.EfCoreGenerator!;
            });

        // Combine compilation with configuration
        var compilationAndConfig = context.CompilationProvider.Combine(configuration);

        context.RegisterSourceOutput(compilationAndConfig,
            (spc, source) => 
            {
                var compilation = source.Left;
                var config = source.Right;
                
                // Only run if base detection is enabled (EfCore generator needs base classes to exist)
                if (!config.EnableBaseDetection) return;
                
                Execute(compilation, config, spc);
            });
    }


    private static void Execute(Compilation compilation, EfCoreGeneratorOptions config, SourceProductionContext context)
    {
        // Use only EfCore discovery methods since base generator handles Common methods
        // and also handles EfCore methods when EfCore detection is enabled
        var allDiscoveryMethods = EfCoreDiscoveryMethods.GetEfCoreDiscoveryMethods();
            
        var discoveredTypes = UnifiedTypeDiscovery.DiscoverTypes(compilation, allDiscoveryMethods);
        
        // Add diagnostic file if enabled
        if (config.EnableDiagnosticFiles)
        {
            var discoveryStats = discoveredTypes
                .GroupBy(dt => $"{dt.Source}-{dt.DiscoveredBy}")
                .Select(g => $"{g.Key}: {g.Count()}")
                .ToList();
                
            context.AddSource("_EfCoreGeneratorDiagnostic.g.cs", $@"
// Generated by EfCore generator at {System.DateTime.Now}
// Assembly: {compilation.Assembly.Name}
// ConfiguredAssemblyName: {config.AssemblyName}
// Base Detection Enabled: {config.EnableBaseDetection}
// Diagnostic Files Enabled: {config.EnableDiagnosticFiles}
// Config Keys Found: {config.DebugInfo}
// Discovery Methods: EfCore only ({EfCoreDiscoveryMethods.GetEfCoreDiscoveryMethods().Length} methods)
// Discovered types: {discoveredTypes.Count}
// Discovery breakdown: {string.Join(", ", discoveryStats)}
// Types: {string.Join(", ", discoveredTypes.Select(dt => $"{dt.TypeSymbol.Name} ({dt.Source} by {dt.DiscoveredBy})"))}
");
        }

        // Filter for entity types discovered by EfCore methods only
        var efCoreEntityTypes = discoveredTypes
            .Where(dt => dt.DiscoveredBy == "EfCore")
            .Select(dt => dt.TypeSymbol)
            .ToList();

        // Create a HashSet for fast lookups using netstandard2.0 compatible approach
        var entityTypeSet = new HashSet<INamedTypeSymbol>(efCoreEntityTypes, SymbolEqualityComparer.Default);

        // Generate EfCore extensions for all entity types found
        // NOTE: This generator ONLY generates EfCore extensions (partial class extensions)
        // Base MetaType classes are generated by the base generator when EfCore detection is enabled
        if (entityTypeSet.Count > 0)
        {
            foreach (var entityTypeSymbol in entityTypeSet)
            {
                // Generate extension using configured assembly name or entity's original assembly namespace
                var entityAssemblyName = !string.IsNullOrEmpty(config.AssemblyName) ? config.AssemblyName! : entityTypeSymbol.ContainingAssembly.Name;
                var efCoreExtensionSource = GenerateEfCoreExtension(entityTypeSymbol, entityAssemblyName);
                context.AddSource($"{entityTypeSymbol.Name}EfCoreMetaType.g.cs", efCoreExtensionSource);
            }
        }
    }


    private static string GenerateEfCoreExtension(INamedTypeSymbol typeSymbol, string assemblyNamespace)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using MetaTypes.Abstractions;");
        
        // For cross-assembly support, we need to ensure we have the right using statements
        var entityNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
        var entityAssemblyName = typeSymbol.ContainingAssembly.Name;
        
        // If the entity is from a different assembly, we need to reference its namespace
        if (entityAssemblyName != assemblyNamespace && !string.IsNullOrEmpty(entityNamespace))
        {
            // Add using for the entity's assembly namespace where MetaType classes are generated
            sb.AppendLine($"using {entityAssemblyName};");
        }
        
        sb.AppendLine();
        // Use the entity's assembly namespace where the original MetaType classes are generated
        // This allows partial classes to extend MetaTypes in their original namespace
        sb.AppendLine($"namespace {entityAssemblyName};");
        sb.AppendLine();
        
        // Get properties for analysis
        var properties = typeSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToArray();
        
        // Generate partial class extension for the MetaType class with EfCore interface
        sb.AppendLine($"public partial class {typeSymbol.Name}MetaType : IMetaTypeEfCore");
        sb.AppendLine("{");
        
        // Get table name from [Table] attribute or derive from type name
        var tableName = GetTableName(typeSymbol);
        sb.AppendLine($"    public string? TableName => \"{tableName}\";");
        
        // Generate Keys collection
        var keyProperties = properties.Where(IsKeyProperty).ToArray();
        sb.AppendLine();
        sb.AppendLine("    public IReadOnlyList<IMetaTypeMemberEfCore> Keys => [");
        foreach (var keyProperty in keyProperties)
        {
            sb.AppendLine($"        {typeSymbol.Name}MetaTypeMember{keyProperty.Name}.Instance,");
        }
        sb.AppendLine("    ];");
        
        sb.AppendLine("}");
        sb.AppendLine();
        
        // Generate partial class extensions for each member with EfCore interface
            
        foreach (var property in properties)
        {
            sb.AppendLine($"public partial class {typeSymbol.Name}MetaTypeMember{property.Name} : IMetaTypeMemberEfCore");
            sb.AppendLine("{");
            
            // Check if this property is a primary key
            var isKey = IsKeyProperty(property);
            sb.AppendLine($"    public bool IsKey => {(isKey ? "true" : "false")};");
            
            // Check if this property is a foreign key
            var isForeignKey = IsForeignKeyProperty(property);
            sb.AppendLine($"    public bool IsForeignKey => {(isForeignKey ? "true" : "false")};");
            
            // Check if this property is marked as not mapped
            var isNotMapped = IsNotMappedProperty(property);
            sb.AppendLine($"    public bool IsNotMapped => {(isNotMapped ? "true" : "false")};");
            
            // For now, we'll set ForeignKeyMember to null - this would need more complex analysis
            sb.AppendLine("    public IMetaTypeMember? ForeignKeyMember => null;");
            
            sb.AppendLine("}");
            sb.AppendLine();
        }
        
        return sb.ToString();
    }

    private static string? GetTableName(INamedTypeSymbol typeSymbol)
    {
        var tableAttribute = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.DataAnnotations.Schema.TableAttribute");
            
        if (tableAttribute?.ConstructorArguments.Length > 0)
        {
            var tableName = tableAttribute.ConstructorArguments[0].Value?.ToString();
            if (!string.IsNullOrEmpty(tableName))
            {
                return tableName;
            }
        }
        
        // Fallback to type name if no explicit table name
        return typeSymbol.Name;
    }

    private static bool IsKeyProperty(IPropertySymbol property)
    {
        // Check for [Key] attribute
        var keyAttribute = property.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.DataAnnotations.KeyAttribute");
            
        if (keyAttribute != null)
        {
            return true;
        }
        
        // EF Core convention: property named "Id" or "{TypeName}Id" is considered a key
        var typeName = property.ContainingType.Name;
        return string.Equals(property.Name, "Id", StringComparison.OrdinalIgnoreCase) ||
               string.Equals(property.Name, $"{typeName}Id", StringComparison.OrdinalIgnoreCase);
    }

    private static bool IsNotMappedProperty(IPropertySymbol property)
    {
        // Check for [NotMapped] attribute
        var notMappedAttribute = property.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.ComponentModel.DataAnnotations.Schema.NotMappedAttribute");
            
        return notMappedAttribute != null;
    }

    private static bool IsForeignKeyProperty(IPropertySymbol property)
    {
        // Simple heuristic: property name ends with "Id" and is not a primary key
        return property.Name.EndsWith("Id", StringComparison.OrdinalIgnoreCase) && 
               !IsKeyProperty(property);
    }
}